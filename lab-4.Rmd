---
title: "Lab 4"
pagetitle: "Lab 4"
output:
  html_document:
    theme: spacelab
    css: style.css
    toc: true
    toc_float: true
    toc_depth: 4
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<br>

## Introduction

This lab introduces spatial data models for representing geographic entities and phenomena and the data structures which implement these spatial data models in Google Earth Engine. 

<br>

## Client and Server

Up to now you have been writing JavaScript programs that are executed by your browser and run on the hardware in your local machine (i.e. any data in variables you declare reside in your computer's memory and the operations or functions you invoke run on your computer's CPU). 

However, your machine has limited storage, memory, and processing power. Google Earth Engine allows you to access servers comprising more powerful computers and access to larger datasets (than could be stored on your local machine). You still write a Google Earth Engine program in JavaScript using the code editor in your browser; however, the servers storing and processing the geospatial data in your program are remotely located in the cloud. 
The execution of a Google Earth Engine program is as follows:

1. You write a series of JavaScript statements that identify geospatial data, and operations to perform on this data, that run on remote servers and the results to be returned from this processing.
2. Your browser encodes these statements and sends them in a message to the Google Earth Engine servers via the internet.
3. The Google Earth Engine servers process your message, access data you requested, and perform the operations outlined in your script.
4. Results your program requests back from the Google Earth Engine servers are returned to your browser (again via the internet) and displayed (e.g. a map is drawn in your browser, results are printed to the console, a file is made available to download).

This differs from a desktop GIS (e.g. QGIS) where all the data and processing occurs locally on your machine's hardware. Google Earth Engine is a distributed system which means the program runs by calling functions running on different computers connected via a network (e.g. your Google Earth Engine programs will call functions running locally in your browser and also functions running on Google servers with data shared between these functions over the internet). Google Earth Engine has a clear client-server architecture where your browser is the client requesting services from Google Earth Engine, the server, which offers a range of services and processes and responds to client requests. 

There are several advantages to this mode of computing. It is more efficient to just download the result of processing geospatial data than to download all the raw data and process and store it locally. For example, if you wanted to compute the area of forest in Australia using a land cover map you can perform this analysis in the cloud and download one number (the area of forest). Contrast this with having to download a land cover map for all of Australia, process the data, and then run the analysis to calculate the area of forest on your local machine. Also, more geospatial datasets are coming online and they getting larger; it is often not feasible to process all this "big data" locally.  

## The `ee` object

It is important to distinguish between variables that are stored, and operations that are run, locally on your machine and data and operations that run on Google servers in the cloud. The `ee` prefix indicates that the data being referred to in your script is a server side object. For example, `var localString = 'on my computer'` is a string type variable stored locally on your machine where as `var cloudString = ee.String('in the cloud')` is a proxy object for a variable containing string data located on servers in the cloud. 

In general, any variable that is declared as `ee.<Thing>()` is server side and any method or operation of the form `ee.<Thing>().method()` is a server side operation. One way of understanding `ee.<Thing>()` is as a container that you put instructions inside to send to the Google servers; for example, in `var cloudString = ee.String('in the cloud')` you are putting a client side string `'in the cloud'` in a container and that data is sent to servers in the cloud. Similarly, you could put the ID of geospatial data that is stored in databases located on Google Earth Engines servers and assign it to server side variables that are used in your program; executing `var landsatImage = ee.Image('LANDSAT/LC8_L1T_TOA/LC81130822014033LGN00')` will assign the Landsat image with the specified ID to the variable `landsatImage` in your script. 

If the geospatial data and operations used in your program are server side how do you access or visualise the results? There are a range of functions in Google Earth Engine that let you request data from the server to be displayed in your browser. For example, the `print()` function can request server side objects and print them to the *Console* and the `Map.addLayer()` function requests spatial data which is displayed in the map. 

<br>

## Spatial Data Models

A spatial data model refers to a conceptual model for describing geographic phenomena or entities. A spatial data model typically contains two pieces of information: 

* positional information describing location (e.g. an `(x, y)` coordinate pair representing the location of a weather station)
* attribute information describing characteristics of the phenomena or entity (e.g. a name:value pair recording the name of the weather station `name:'Perth Airport'`) 

A spatial data model is a *representation* of geographic phenomena or entities; therefore, some detail is abstracted away. 

### Vector Data Model

The vector data model represents geographic phenomena or entities as geometric features: 

* points (i.e. a coordinate pair of values)
* lines (i.e. two or more points connected by a line) 
* polygons (i.e. three or more points connected by a non-intersecting line which "closes" the polygon) 

Along with coordinates that represent the position of the geometry, vector data also stores non-spatial attribute information which describe characteristics of the geographic phenomena or entity represented by the geometry feature.

The figure below demonstrates how geographic entities in Perth can be represented using the vector data model. The blue line feature broadly captures the shape of the river; however, it is a simplification as it does not provide information about how the river's width varies across space. The red point feature is used to represent the location of Perth; this might be an appropriate way to represent Perth's location on a zoomed out map but it does not capture Perth's actual extent across the landscape. 


<br>
<details>
  <summary><b>*What detail is abstracted away by representing Kings Park using the green polygon feature?*</b></summary>
  <p><ul>
  <li>Shape of Kings Park is simplified using only 6 vertices.</li>
  <li>Variation in land cover types and land uses within the park is not captured.</li>
</ul></p>
</details>
<br>

<center>

```{r vector-data-model, fig.align = 'center', out.width = "70%", fig.cap = "Representing geographic entities using the vector data model", echo = FALSE}
knitr::include_graphics("img/vector-data-model.png")

```
</center>
<br>

### Raster Data Model

The raster data model represents geographic phenomena or entities as a grid of cells (pixels). Attribute information about geographic phenomena or entities is described by assigning a value to each pixel. The dimensions of a pixel relative to distance on the Earth's land surface determines the complexity and detail of spatial features that can be resolved in raster data. A pixel that represents a 1 km x 1 km footprint on the Earth's surface will not be able to resolve an individual tree or a single building. Pixel values can be continuous (e.g. values represent precipitation) or categorical (e.g. values represent a land cover type).

The figure below shows the 2018 European Space Agency (ESA) [Climate Change Initiative (CCI) land cover map](https://www.esa-landcover-cci.org) for 2018. This is a raster data model representation of land cover; each pixel represents a 300 m x 300 m area on the Earth's land surface and a pixel can only represent a single land cover type. If you look at the bottom two zoomed in maps you can some limitations of modelling land cover using 300 m x 300 m spatial resolution raster data. The shape of features of different land cover types is poorly represented by the "block-like" arrangement of pixels and there is variation in land cover within a single pixel. 

<br>
<center>

```{r raster-data-model, fig.align = 'center', out.width = "70%", fig.cap = "Representing land cover using the raster data model", echo = FALSE}
knitr::include_graphics("img/raster-data-model.png")

```
</center>


<br>
<details>
  <summary><b>*How could you represent spatial variation in elevation using vector and raster data models?*</b></summary>
  <p><ul>
  <li>Vector data model: contour lines.</li>
  <li>Raster data model: digital elevation model (DEM) - each pixel value represents the elevation at that location.</li>
</ul></p>
</details>
<br>


## Data Structures

Data structures are how spatial data models are implemented in a computer system. GEE has a range of non-spatial data structures used for organising data related to geographic and non-geographic information. 
<center>
<table style="width:75%; border-collapse: collapse; border-bottom: 1px solid #ddd; padding: 15px;">
  <caption>Google Earth Engine Data Structures</caption>
  <tr>
    <th>Name</th>
    <th>Constructor</th>
    <th>Summary</th>
  </tr>
  <tr>
    <td>String</td>
    <td>`ee.String()`</td>
    <td>Create a string object on the GEE server. Useful for storing text data (e.g. name of a weather station) and metadata.</td>
  </tr>
  <tr>
    <td>Dictionary</td>
    <td>`ee.Dictionary()`</td>
    <td>Create a dictionary object on the GEE server. Dictionary object comprise key and value pairs which describe properties of an object (e.g. a dictionary object could contain key attributes about a point feature representing a city - `{city: 'Perth', population: '1000000'}` - or metadata about a remote sensing image capture - `{CLOUD_COVER: 0.059, DATE_ACQUIRED: 2014-03-18, DATUM: WGS84}`).</td>
  </tr>
   <tr>
    <td>Number</td>
    <td>`ee.Number()`</td>
    <td>Create a number object on the GEE server. Useful for storing quantitative data (e.g. the result of a mathematical operation or a numeric measurement such as temperature).</td>
  </tr>
  <tr>
    <td>List</td>
    <td>`ee.List()`</td>
    <td>Create a list object on the GEE server. Useful for organising different objects (e.g. a list can store images, features, an array, and a string in one object - `var list = ee.List([1, 'text']);`).</td>
  </tr>
  <tr>
    <td>Array</td>
    <td>`ee.Array()`</td>
    <td>Create an array object on the GEE server. 1-D vector, 2-D matrics, 3-D cubes, or n-D hypercubes. Arrays are created from lists of numbers and lists of lists (e.g. `var arr = ee.Array({[1, 2], [1, 2]});` - a 2x2 array). This demonstrates how complex data structures and objects are constructed from simpler data structures.</td>
  </tr>
  <tr>
    <td>Date</td>
    <td>`ee.Date()`</td>
    <td>Create a date object on the GEE server. Useful for storing temporal attributes about geographic data (e.g. date of satellite image capture).</td>
  </tr>
</table>
</center>

<br>

## Spatial Data Structures

### Images

Raster data in GEE are represented as `Image` objects. 

To create an `Image` object that stores raster data on the GEE server use the `ee.Image()` constructor. You pass arguments into the parentheses of the `ee.Image()` constructor to specify what raster data should be represented by the `Image` object. If you pass a number into `ee.Image()` you will get a constant `Image` where each pixel value is the number passed in. 

Add the following code to your GEE script. This will create an `Image` object where each pixel has the value 5 which can be referred to using the variable `img5`. Click on the *Inspector* tab and then click at locations on the map. You should see the value 5 printed in the *Inspector* tab.

```{js, echo=TRUE, eval=FALSE}
/*Raster where pixel values equal 5*/
var img5 = ee.Image(5);
print(img5);
Map.addLayer(img5, {palette:['FF0000']}, 'Raster with pixel value = 5');

```

Alternatively, you can pass a string id into the `ee.Image()` constructor to specify a GEE asset (e.g. a Landsat image). 

The variable `img` refers to an `Image` object on the GEE servers storing the Landsat 8 data. This variable can be used in a script to access the Landsat data for queries and analyse. Pass the variable `img` into the `print()` function to query the Landsat 8 image's metadata. The Image metadata should be printed in the *Console* tab.

```{js, echo=TRUE, eval=FALSE}
/*Pass Landsat 8 image id into Image constructor*/ 
var img = ee.Image('LANDSAT/LC8_L1T_TOA/LC81130822014033LGN00');
print(img);

```

An `Image` can have one or more bands, each band is a georeferenced raster which can have it's own set of properties such as data type (e.g. Integer), scale (spatial resolution), band name, and projection. The `Image` object itself can contain metadata relevant to all bands in a dictionary object.

Go to the *Console* tab and you should see the Landsat 8 `Image` has 12 bands. Click on a band and you should see some band specific properties such as its projection (`crs: EPSG:32650`). Click on the `Image` `properties` to explore metadata that applies to the `Image` object such as cloud cover at the time of image capture (`CLOUD_COVER: 11.039999961853027`) or satellite carrying the sensor (`SPACECRAFT_ID: LANDSAT_8`).


### Geometry Objects

### Features

### Collections